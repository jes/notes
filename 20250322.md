# 2025-03-22

## Interval arithmetic

I think the way I'm going to do this is add two new types to Peptide:
"ifloat" and "ivec3", that do interval arithmetic.

And then some way to turn a straightforward expression into an interval
expression. You pass it something to say which of your variables will
transform into the interval equivalent (for me I think that is just `p`,
but no reason not to make it general).

Then DFS the tree and replace instances of those variables with the
interval equivalent, and when any node that expects non-interval
children has an interval child, it converts itself into the interval
equivalent. If you have one child that is an interval and one that is
regular, I guess you convert the regular one into a 0-sized interval first.

For a start I can just do some basic add/mul/sub/div of floats
and then write tests for it, and then expand until I can turn SDFs
into intervals.

Actually, a couple of other thoughts are:

 * we can transform *all* nodes into interval equivalents, and then transform the interval version back into a regular version that implements it, and then common subexpression elimination will automatically solve what needs to be intervals and what needs to be regular?
 * we could skip any transformation into an interval form and just add a second set of closures that implement the interval version

I think the latter might be easiest, but it will unnecessarily do
interval arithmetic even on subtrees that consist entirely of 0-sized
intervals.

But premature optimisation is bad. I think let's do it this way.

OK, I have it passing quite a lot of tests with interval arithmetic.
Not all of them.

`smin()`/`smax()` have divisions by intervals that cross 0, not sure
what is wrong there. And `mvmul()` is not implemented yet so tests that
use it can't work.

I am making `float`s and `vec3`s use intervals, but matrices are staying
as plain `mat3`s because matrices are only ever allowed to
be constants or input variables. You can't construct matrices using
Peptide, which means they never need to contain intervals.

Once all the tests are passing with interval arithmetic, I will want
to do the "compiled JavaScript" version of interval arithmetic, and
finally "compiled GLSL". And then I can make the shader do binary
searching over intervals! And then I can make min/max skip paths that
can't contribute to the interval.

OK, all tests now passing!

Next up is the "compiled JavaScript" version.

OK, done, pretty straightforward, one issue is that the
trigonometric functions behave pretty weirdly in interval arithmetic.

I think uniquely, they don't necessarily reach min/max at the min/max
of the operands.

OK, I now have interval arithmetic for sin/cos, and the compiled JS
code is passing the tests.

Last thing is compiled GLSL interval arithmetic code, and then a
binary search ray marching shader.

## Graph numbering

Given a directed graph, compute an integer that uniquely identifies that graph.
2 identical graphs should get the same Graph Number, and 2 different
graphs should get different Graph Numbers.

You need to be able to efficiently compute the Graph Number, and bonus
points if you can efficiently reverse it.

First idea:

 * label the nodes of the graph arbitrarily
 * compute the adjacency matrix
 * (add an additional column to the matrix containing just a single "1" to specify the number of nodes)
 * permute the matrix into a canonical form (can you sort the rows/columns somehow?)

Now you have an adjacency matrix that uniquely identifies the graph.

For each row, treat it as a binary number *n_i*, and accumulate
**2^n_0 + 3^n_1 + 5^n_2 + 7^n_3 + ...**, i.e. the Godel numbering of
the columns.

And then you have your Graph Number.

But it's difficult to reverse because you need to find the prime
factorisation.

So the next idea is to use "variable-base numbering" e.g. https://incoherency.co.uk/blog/stories/chess-steg.html to convey first the size of the matrix, and then a bitstream for the contents of the matrix.

So the only issue is how you permute the matrix into a canonical form.

And then we have a mapping from graphs to integers, which also
proves that the set of graphs is not an uncountable infinity.

Apparently "nauty" has a scheme for canonical vertex labelling:
https://math.stackexchange.com/questions/4315998/canonical-labelling-in-nauty-mckay

https://pallini.di.uniroma1.it/Introduction.html
