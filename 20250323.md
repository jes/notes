# 2025-03-23

## Interval arithmetic

I am having an issue because it keeps trying to take the square root of
an interval that contains negative numbers.

I think the reason for this is I am computing lots of "squares"
as `a*a` for example, but that means the resulting interval is much
wider than it needs to be.

OK, so interval arithmetic is actually much harder than I thought.
(Story of my life).

I made multiplication detect if the 2 arguments are the same and turn
into squaring in that case. This isn't a completely general solution
in the `evaluateInterval()` case
because it is detecting whether the un-simplified arguments are the
same. Ideally would be looking at the arguments after `simplify()` has
had a chance to clean them up. For the code generation cases it is
fine.

Now it is getting NaN for the distance value, not yet sure why.

I had messed up the rotation matrix multiplication.

And now it is always getting an interval that crosses 0.

Oh, one issue is it was cloning the Ivec3 wrong.

It looks like it is *almost* working on the sphere now. Still not
working properly on the default object.

My suspicion is that the reason it's not working is because the
interval tells you that it *might* cross the surface of the object,
rather than that it *definitely does*. So if I split an interval
in half and find that neither half crosses the surface, currently
I just split until the end of the second half and then say that's where
the surface must be, but really I need to be breaking into the second
half of the parent interval and searching there instead.

Or, maybe I'm wrong and it actually can provide tight bounds?
