# 2025-03-21

## Shader layers

I'm going to make a `ShaderLayer` class that has a compiled shader
and a bunch of uniform values. The "renderer" will take a series of
"ShaderLayers" to draw. The "app" will keep one ShaderLayer for the
primary object and one for the secondary object, if any, and pass them
both to the renderer.

And then the renderer is dealing with OpenGL stuff, but the rest of the
application is just dealing with setting uniforms in the ShaderLayer.

Great, working!

And the secondary object is now always shown with genuine reduced opacity,
rather than being drawn solid but blended on top, so we do get to see
the inside of the secondary object now:

https://img.incoherency.co.uk/6061

## SketchNode

If the first point it not at (0,0) you get this:

https://img.incoherency.co.uk/6062

It still has a surface point at (0,0), and then randomly can't
decide whether it is inside or outside for some region?

Claude debugged it for me, fixed now.

But the "3d distance" thing isn't working. Ah, it's because I was
overriting `p` at the start of the function to turn it 2d, and then
later on trying to access its Z coordinate.

## rotateToAxis

I don't currently have a way to do the `rotateToAxis()` stuff with
Peptide.

So I need it to have a `mat3` type, and I need to implement:

 * rotateToAxis(vec3) -> mat3
 * transpose(mat3) -> mat3
 * mmul(mat3, mat3) -> mat3
 * mvmul(mat3, vec3) -> vec3

Expression simplification seems to be taking quadratic time. Seems wrong.

It's actually at the point now where simplifying the expression into a
DAG is taking longer than shader compilation!

It actually seems to work quite well if I skip simplification.

Without simplification we get 48 fps at resolution scale 2.519 with
10 copies of the revolved sketch with blend radius 1 at spacing 20mm.

With simplification, and the same model but only 6 copies, we get
47 fps at resolution scale 2.832.

Cache size is:

 * sketch only: 116
 * with revolve: 122
 * with LinearPattern 2 copies: 220
 * with LinearPattern with blend: 231
 * with 3 copies: 337
 * with 4 copies: 443
 * with 5 copies: 549
 * with 6 copies: 655

So the cache size is not getting crazy large, what about "key"
evaluations?

 * sketch only: 2140
 * revolve: 4960
 * LinearPattern: 11613
 * with blend: 46485
 * 3 copies: 212585
 * 4 copies: 876985

I don't see why adding 1 more copy quadruples the number of key
evaluations. I think it's because `smin()` basically references
its arguments 5 times.

I think this is not recognising when it has already simplified a
particular object. I made it set the objects in the `Map` as well
as the stringified versions. And then we get:

 * sketch only: 153
 * revolve: 161
 * LinearPattern: 324
 * with blend: 339
 * 3 copies: 517
 * 4 copies: 695

Much better.

## Todo

 * Why doesn't Revolve of LinearPattern of Sketch work properly?
 * Let Revolve take an axis and an angle
 * domain repetition for patterns (with bounding spheres? explicit bounding box from user? how else?)
 * Stop repeating the "minFn" derivation
 * Unit tests for Peptide SDFs (some hardcoded points and distances? or at least whether they're inside or outside)
 * Interval arithmetic rendering
 * Interval arithmetic marching cubes
