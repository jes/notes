# 2025-03-16

## Isoform

So I think the plan is to switch to using an intermediate
arithmetic tree representation in between the document tree and the GLSL. And then we
can:

 * evaluate the arithmetic tree at either a point or an interval, in JavaScript
 * generate GLSL for evaluating it at either a point or an interval
 * marching cubes with intervals will work really well because you can easily rule out an entire voxel in one evaluation

So that will want to be the "CAD kernel" for Isoform, which can be ripped out and made into
a separate "project", provisionally called "Peptide".

And this guides the kind of work I should be doing on Isoform in the immediate term:
UI improvements are totally irrelevant, I only need to be working on things that will
affect the kinds of SDFs that we need.

So I should add more node types:

Primitives:

 * more lattices
 * helix extrude
 * cone
 * ellipsoid
 * text

Modifiers:

 * bend
 * shear
 * taper
 * slice
 * offset (maybe as part of Thickness? or the other way around)

In particular I think we *can't* have conditionals in the SDFs, because you can't do
interval arithmetic on them. You'd have to evaluate both sides and then take the min
and max.

I'm also keen to find out if there's a good way to do "tape shortening" in GLSL. We could
have each min/max node set a flag to say if it should go one way or the other, and as
long as we are continually iterating within the same interval we let the flags persist,
and if we need to evaluate a different interval we reset all the flags? Can you do
better than resetting all the flags? Remember what they were from the previous run?
You only need to stash 1 extra set of flags, because you only ever "backtrack" 1 level
(either you take the first half of the interval or the second).

And I still really want to do the thing where you can use some modifier function to
deform the domain of a LinearPattern or whatever, without deforming the actual object.

Or, for example, combine a distance deformation with a lattice, so that we only
roughen it in a gyroid pattern. So we'd be using the lattice (or any other object)
to mask the deformation.

But I can start with the primitives/modifiers above and get SDFs for them so that I have
something to work from when making Peptide.

Lattices: https://en.wikipedia.org/wiki/Triply_periodic_minimal_surface

## Meshing

I've been messing around in Isoform a bit and made this shape:

https://img.incoherency.co.uk/6053

The rendering is a bit bad because I had to reduce step factor because of the chamfer
on the bottom.

I kind of want to 3d print this object, just to hold it in my hands, but I still don't
have support for meshing.

Meh, I guess the quickest way is to do "Peptide" first and then use it to implement
marching cubes.

## Helix extrude

How would you do a helical extrude? You need to calculate the distance to the closest point
on the extrusion, which I don't really see how you could do?

There is a project called "RayTK" that has https://t3kt.github.io/raytk/reference/operators/sdf/helixSdf

There are lots of other potentially useful SDFs in that project as well.

That takes an input for a "cross section shape". It also lets you specify some of the
parameters as "fields" instead of constants. Is this something I should be doing?

Internally, we could have "field" nodes which just return some value, and then we can
have "add field" and "multiply field", for both domain and distance. "Add field" takes
a vector field, "Multiply field" takes a scalar field.

So translation would add a constant vector to the domain.

Uniform scaling will multiply the domain by a constant scalar.

One massive advantage of the binary search renderer is that we still render the
0 surface perfectly even if the distance field is totally wrong. (But we still *care*
about the distance field for other reasons).

## Renormalise

The picture from the other day: https://img.incoherency.co.uk/6051

Showing a thickness of a chamfered PolarPattern of boxes.

If I add a "renormalise" function that divides the distance by the
local gradient (or... multiplies by?), will that fix this?

No, it doesn't work. It has some discontinuities, which then makes
the Thickness operation very badly discontinuous.

https://img.incoherency.co.uk/6054
